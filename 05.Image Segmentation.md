# 图像分割（Image Segmentation）


```python
# download data
'''
! wget https://bc-cv.github.io/csci3397/public/dip_registration/exemplar-001-cycle-01.ome.tiff -O exemplar-001-cycle-01.ome.tiff
! wget https://bc-cv.github.io/csci3397/public/dip_morph/binary_hole.png -O binary_hole.png
! wget https://bc-cv.github.io/csci3397/public/dip_morph/binary_noise.png -O binary_noise.png
! wget https://bc-cv.github.io/csci3397/public/dip_morph/binary_fm.png -O binary_fm.png
! wget https://bc-cv.github.io/csci3397/public/dip_morph/binary_fs.png -O binary_fs.png
! wget https://bc-cv.github.io/csci3397/public/dip_morph/cell.png -O cell.png
! wget https://bc-cv.github.io/csci3397/public/dip_morph/messi.png -O messi.png
'''
# auxilary function
import matplotlib.pyplot as plt
from imageio.v2 import volread, imread
import numpy as np


def plotImgPair(img1, img2, cm = 'gray', title=['','']):
    fig, ax = plt.subplots(1, 2, figsize=(15, 20))
    for i,a in enumerate(ax):
        a.set_axis_off()
        if title[i] != '':
            a.set_title(title[i])
    ax[0].imshow(img1, cmap=cm)
    ax[1].imshow(img2, cmap=cm)

def imAdjust(I, thres=[1,99]):
    # compute percentile: remove too big or too small values
    I_low, I_high = np.percentile(I.reshape(-1), thres)
    # thresholding
    I[I > I_high] = I_high
    I[I < I_low] = I_low
    # scale to 0-1
    I = (I.astype(float)- I_low)/ (I_high-I_low)
    # convert it to uint8
    I = (I * 255).astype(np.uint8)
    return I
```

# <b>1. 语义分割（Semantic segmentation）</b>


```python
img1 = imAdjust(volread('image/exemplar-001-cycle-01.ome.tiff')[0,687:787,687:787])

plt.figure(figsize=(8, 8))
plt.imshow(img1, cmap='gray')
plt.axis('off')
plt.show()

```


    
![png](output_3_0.png)
    


## 1.1 朴素阈值处理（Naive thresholding）


```python
ths = [30,70,120]

plt.figure(figsize=(16, 8))

for i,th in enumerate(ths):
    seg_semantic = (img1 > th)
    plt.subplot(1,3,i+1)
    plt.imshow(seg_semantic, cmap='gray')
    plt.title('Threshold %d' % th)
    plt.axis('off')

```


    
![png](output_5_0.png)
    


## 1.2 Otsu 阈值处理（Otsu thresholding）

在实践中，可以对图像应用高斯滤波器进行轻微去噪，以便两个类别可以更好地分离。

<img src="image/otsu.jpg">

[More details](https://docs.opencv.org/4.x/d7/d4d/tutorial_py_thresholding.html)


```python
import cv2

# direct Ostu
th_otsu, img1_otsu = cv2.threshold(img1, 0, 255, cv2.THRESH_BINARY+cv2.THRESH_OTSU)

# Gaussian blur + Ostu
img1_blur = cv2.GaussianBlur(img1,(5,5),0)
th_blur_otsu, img1_blur_otsu = cv2.threshold(img1_blur, 0, 255, cv2.THRESH_BINARY+cv2.THRESH_OTSU)



plt.figure(figsize=(12, 8))
plt.subplot(121)
plt.imshow(img1_otsu, cmap='gray')
plt.title('Otsu Threshold %d' % th_otsu)
plt.axis('off')
plt.subplot(122)
plt.imshow(img1_blur_otsu, cmap='gray')
plt.title('Gaussian+Otsu Threshold %d' % th_blur_otsu)
plt.axis('off')
```




    (np.float64(-0.5), np.float64(99.5), np.float64(99.5), np.float64(-0.5))




    
![png](output_7_1.png)
    


# <b>2. 实例分割（Instance segmentation）</b>

## 2.1 连通组件（Connected component）


```python
from skimage.measure import label
from skimage.color import label2rgb


seg_inst = label(img1_blur_otsu)

plt.figure(figsize=(8, 8))
plt.subplot(121)
plt.imshow(seg_inst, cmap='gray')
plt.title('direct visualization (hard to tell)')
plt.axis('off')
plt.subplot(122)
plt.imshow(label2rgb(seg_inst, bg_label=0))
plt.title('assign random colors')
plt.axis('off')

```




    (np.float64(-0.5), np.float64(99.5), np.float64(99.5), np.float64(-0.5))




    
![png](output_10_1.png)
    


## 2.2 分水岭（Watershed）


### Step 1. 距离变化（Distance transform）


```python
from scipy import ndimage as ndi
distance = ndi.distance_transform_edt(img1_blur_otsu)
plotImgPair(img1_blur_otsu, distance, title=['binary mask', 'distance transform'])
```


    
![png](output_13_0.png)
    


### Step 2. 寻找局部最优解（Find local optima）


```python
from skimage.feature import peak_local_max

# partially determined by the size of a cell
optima_window_size = 15

coords = peak_local_max(distance,\
                        footprint=np.ones((optima_window_size, optima_window_size)),\
                        labels=img1_blur_otsu)
mask = np.zeros(distance.shape, dtype=bool)
mask[tuple(coords.T)] = True
markers, _ = ndi.label(mask)

# the points are small
plotImgPair(mask, label2rgb(markers, bg_label=0), title=['local optima','each optima has a different seg id'])
```


    
![png](output_15_0.png)
    


### Step 3. 分水岭变换（Watershed transform）

它修复了错误合并的问题，但引入了一些错误的分割……


```python
from skimage.segmentation import watershed
seg_watershed = watershed(-distance, markers, mask=img1_blur_otsu)
plotImgPair(img1, label2rgb(seg_watershed, bg_label=0), title=['input image','watershed segmentation'])
```


    
![png](output_17_0.png)
    


## 2.3 基于图的分割（Graph-based Segmentation）

https://docs.opencv.org/3.4/d8/d83/tutorial_py_grabcut.html

### 矩形掩膜（Rectangle mask）


```python
img = imread('image/messi.png')
rect = (161,20,320,370)
plotImgPair(img, img[rect[1]:rect[1]+rect[3], rect[0]:rect[0]+rect[2]])
```


    
![png](output_20_0.png)
    



```python
import cv2

# zero initialization
mask = np.zeros(img.shape[:2],np.uint8)
bgdModel = np.zeros((1,65),np.float64)
fgdModel = np.zeros((1,65),np.float64)
num_iter = 5


cv2.grabCut(img, mask, rect, bgdModel,fgdModel,num_iter,cv2.GC_INIT_WITH_RECT)

img2 = img.copy()
# find background region
mask_bg = np.tile(((mask==2)+(mask==0)).astype('uint8')[:,:,None], [1,1,3])
img2[mask_bg>0] = 128
plt.imshow(img2),plt.colorbar(),plt.show()
```


    
![png](output_21_0.png)
    





    (<matplotlib.image.AxesImage at 0x23bcb491820>,
     <matplotlib.colorbar.Colorbar at 0x23bcb4aa390>,
     None)



### 添加手动校正
上面的掩模是一个很好的初始化。然而，腿部缺失，手臂下方的区域不属于身体。

我们将使用以下GUI来：
- 选择绿色并标记人体的骨架（告诉GrabCut这些像素是前景）
- 选择红色并标记手臂下方的区域（告诉GrabCut这些像素是背景）
- 保存图像

一个示例掩模图像如下所示：

<img width=200 src="image/messi_mask.png">

GUI代码基于 https://gist.github.com/rickkk856/6a2800cc84dd8fd456074e5a467edc47

这里省去了生成掩膜的交互过程，直接利用添加手动校正的掩膜。

可视化带标记的掩膜


```python
# you can optionally download the mask directly
# ! wget https://bc-cv.github.io/csci3397/public/dip_morph/messi_mask.png -O messi_mask.png
plotImgPair(imread('image/messi_mask.png')[:,:,0],imread('image/messi_mask.png')[:,:,1], title=['background','foreground'])
```


    
![png](output_24_0.png)
    



```python
import cv2

bgdModel = np.zeros((1,65),np.float64)
fgdModel = np.zeros((1,65),np.float64)

# mask initialization
mask_rect2 = mask.copy()
mask_manual = imread('image/messi_mask.png')
# background
mask_rect2[mask_manual[:,:,0]>200] = 0
# foreground
mask_rect2[mask_manual[:,:,1]>200] = 1


mask_manual_out, bgdModel, fgdModel = cv2.grabCut(img, mask_rect2, None, bgdModel,fgdModel, num_iter, cv2.GC_INIT_WITH_MASK)
mask_manual_out = np.tile(np.where((mask_manual_out==2)|(mask_manual_out==0),0,1).astype('uint8')[:,:,None], [1,1,3])
img2 = img.copy()
img2[mask_manual_out==0] = 128
plt.imshow(img2)
plt.show()
```


    
![png](output_25_0.png)
    


# <b> 3. 形态学操作（Morphology Operations）</b>


```python
from scipy.ndimage import binary_fill_holes
from scipy.ndimage import binary_erosion,binary_dilation
from scipy.ndimage import binary_closing,binary_opening
```

## 3.1 基本操作


### 填充孔洞（Fill holes）


```python
im_hole = imread('image/binary_hole.png')
im_hole_out = binary_fill_holes(im_hole)
plotImgPair(im_hole, im_hole_out, title=['input image', 'filled holes'])
```


    
![png](output_30_0.png)
    


### 腐蚀：去除噪声（Erosion: remove noise）


```python
im_noise = imread('image/binary_noise.png')
im_noise_out = binary_erosion(im_noise, np.ones([3,3]), 1)
plotImgPair(im_noise, im_noise_out, title=['input image', 'denoised image'])
```


    
![png](output_32_0.png)
    


### 膨胀：修复错误分割（Dilation: fix false split）


```python
im_fs = imread('image/binary_fs.png')
im_fs_out = binary_dilation(im_fs, np.ones([3,3]), 5)
plotImgPair(im_fs, im_fs_out, title=['input image', 'merged false split'])
```


    
![png](output_34_0.png)
    


## 3.2 组合操作（Composite operations）

### 闭运算：修复错误分割 + 保持形状（Closing: fix false splits + preserve shape）


```python
im_fs = imread('image/binary_fs.png')
im_fs_close = binary_dilation(im_fs, np.ones([3,3]), 5)
im_fs_close2 = binary_closing(im_fs, np.ones([3,3]), 5)
plotImgPair(im_fs_close, im_fs_close2, title=['binary dilation', 'binary closing'])
```


    
![png](output_37_0.png)
    


### 开运算：修复错误合并 + 保持形状（Opening: fix false merge + preserve shape）


```python
im_fm = imread('image/binary_fm.png')
#imsave('image/binary_fm.png', im_fm[::8,::8,0])
im_fm_open = binary_dilation(binary_erosion(im_fm, np.ones([3,3]), 25), np.ones([3,3]), 25)
im_fm_open2 = binary_opening(im_fm, np.ones([3,3]), 25)
plotImgPair(im_fm, im_fm_open, title=['input image', 'split false merge'])
```


    
![png](output_39_0.png)
    


# 练习
将上面学到的知识应用到一种新型的细胞图像上
- 细胞边界现在是白色的。白色边界内的各个部分是细胞
- 不需要追求完美的结果。合理的结果就足够了


[[Segmentation of many different types of images/cells]](https://www.cellpose.org/)


```python
from imageio.v2 import imread,imsave

im = imread('image/cell.png')
plt.imshow(im, cmap='gray')
plt.axis('off')
```




    (np.float64(-0.5), np.float64(499.5), np.float64(299.5), np.float64(-0.5))




    
![png](output_41_1.png)
    


## (1) 语义分割（semantic segmentation）

计算二值图像，其中细胞区域为1，背景为0。


```python
### Your code starts here
threshold = 200  
im_seg_semantic = (im > threshold).astype(np.uint8)  

### Your code ends here

plt.imshow(im_seg_semantic, cmap='gray')
plt.axis('off')
plt.show()
```


    
![png](output_43_0.png)
    


## (2) 实例分割（Instance segmentation）

基于上述的语义分割，使用连通组件（connected-component）方法将单个细胞分配给不同的分割 ID，并用随机颜色进行可视化。（有误差是可以的）。


```python
### Your code starts here
from skimage.color import label2rgb

seg_inst = label(img1_blur_otsu)  
seg_inst_color = label2rgb(seg_inst, bg_label=0)  
### Your code ends here


plt.imshow(seg_inst_color)
plt.axis('off')
plt.show()

```


    
![png](output_45_0.png)
    


## (3) 测量和表格 I/O（Measurement and Table I/O）

- 计算所有分割细胞的圆度。（提示：需要获取所需测量的统计数据）
- 将结果保存到CSV文件cell_stats.csv中，标题为：{"cell id", "circularity"}
- 加载结果并绘制圆度直方图


```python

from skimage.measure import label, regionprops_table
from skimage.color import label2rgb
from math import pi
from skimage.measure import regionprops


## find circularity
# first, keep only the nonzero segments (areas that were segmented)
ui,uc = np.unique(seg_inst[seg_inst>0], return_counts=True)

# then, remove small segments below size 100 (smaller segments are artifacts, probably not cells that we're interested in)
thres_size = 100
relabel = np.zeros(ui.max()+1, np.uint16)
relabel[ui[uc>thres_size]] = np.arange(1, (uc>thres_size).sum()+1)
seg_inst_clean = relabel[seg_inst]


### Your code starts here
# lookup area and perimeter from regionprops table, keeping segment label
table_from_clean = regionprops(seg_inst_clean)
# calculate circularity
table_from_clean = regionprops_table(seg_inst_clean, properties=['label', 'area', 'perimeter'])
table_from_clean['circularity'] = (4 * pi * table_from_clean['area']) / (table_from_clean['perimeter'] ** 2)

## save result to csv
# create a Nx2 matrix: id, circularity
out = np.column_stack((table_from_clean['label'], table_from_clean['circularity']))
np.savetxt('cell_stats.csv', out, header='cell id,circularity', delimiter=',', comments='')


## load result and plot circularity histogram
circularity_val = table_from_clean['circularity']

plt.hist(circularity_val)
plt.title('Circularity distribution of cleaned segments')
plt.show()
### Your code ends here
```


    
![png](output_47_0.png)
    

