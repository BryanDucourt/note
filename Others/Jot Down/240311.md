#### eBPF Hybrid Lock: Scalable Spin-based User-Space Locking (Poster)
link:https://inria.hal.science/hal-04262326/
abstract:
多核处理器已经问世很久了，但由于同步问题影响性能，充分利用它们的计算潜能仍然是一个挑战。本工作解决了在响应性较好但在过度订阅的系统中容易崩溃的自旋锁与稳定但反应较慢的阻塞锁之间的选择困境。我们引入了BPF混合锁，这是一种新的同步技术，它基于系统的订阅情况动态地在自旋锁和阻塞锁之间转换。使用eBPF来检测锁持有者的抢占。我们的贡献包括无缝锁转换的算法、增强的条件变量反应性以及检测从自旋锁转换到阻塞锁的最佳时机。我们提供了使用MCS和Linux Futex锁的BPF混合锁的实现，展示了在未充分订阅的系统中的性能改进，例如LevelDB，其中写操作时间从282微秒减少到102微秒，读取时间从40微秒减少到25微秒。
#### Application-Informed Kernel Synchronization Primitives
link:https://www.usenix.org/conference/osdi22/presentation/park
abstract:内核同步原语是任何操作系统设计的骨干。例如，内核锁对于应用程序的性能和正确性都至关重要。然而，与应用程序锁不同，内核锁远离应用开发者的触手可及，他们对内核行为的理解非常有限，无法控制或影响管理内核同步行为的策略。内核与应用程序之间的这种脱节可能导致病态场景，其中在一个高竞争上下文中优化内核同步原语会在无锁竞争的上下文下产生对立的效果。此外，快速演变的异构硬件使得内核锁的开发对于有严格性能要求和频繁部署时间线的现代应用程序来说太慢了。

本文通过应用程序通知的内核同步原语来解决上述问题。我们允许应用开发者部署针对工作负载特定和硬件感知的内核锁策略，以提升应用程序性能，解决内核锁的病态使用，甚至启用对感兴趣的锁进行动态分析。为了展示这个想法，我们设计了SynCord，一个在不重新编译或重启内核的情况下修改内核锁的框架。SynCord抽象了内核锁的关键行为，并将其作为API暴露出来，用于设计用户定义的内核锁。SynCord提供了从用户空间安全、正确地自定义内核锁的机制。我们设计了五种针对新的异构硬件和特定软件要求的锁策略。我们的评估显示，SynCord带来的运行时开销最小，并生成了与最先进的锁性能相当的内核锁。
#### Userspace Bypass: Accelerating Syscall-intensive Applications
link:https://www.usenix.org/conference/osdi23/presentation/zhou-zhe
abstract:在内核模式和用户模式之间进行上下文切换经常会导致显著的开销，这降低了频繁进行系统调用（或称为syscalls）的应用程序的速度，例如那些具有高I/O需求的应用程序。安全机制如Linux内核的页表隔离（KPTI）进一步放大了这种开销。为了加速这类应用程序，许多努力已经被投入到从I/O路径中移除系统调用，主要通过将驱动程序和应用程序合并到同一空间或批处理系统调用。然而，这些解决方案要求开发者重构他们的应用程序甚至更新硬件，这阻碍了它们的广泛采用。
#### 
link：https://dl.acm.org/doi/10.1145/3575693.3575697
