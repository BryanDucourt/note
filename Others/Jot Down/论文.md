#### 方向
![[Pasted image 20240311201245.png]]

#### eBPF Hybrid Lock: Scalable Spin-based User-Space Locking (Poster)
link:https://inria.hal.science/hal-04262326/
abstract:
多核处理器已经问世很久了，但由于同步问题影响性能，充分利用它们的计算潜能仍然是一个挑战。本工作解决了在响应性较好但在过度订阅的系统中容易崩溃的自旋锁与稳定但反应较慢的阻塞锁之间的选择困境。我们引入了BPF混合锁，这是一种新的同步技术，它基于系统的订阅情况动态地在自旋锁和阻塞锁之间转换。使用eBPF来检测锁持有者的抢占。我们的贡献包括无缝锁转换的算法、增强的条件变量反应性以及检测从自旋锁转换到阻塞锁的最佳时机。我们提供了使用MCS和Linux Futex锁的BPF混合锁的实现，展示了在未充分订阅的系统中的性能改进，例如LevelDB，其中写操作时间从282微秒减少到102微秒，读取时间从40微秒减少到25微秒。
#### Application-Informed Kernel Synchronization Primitives
link:https://www.usenix.org/conference/osdi22/presentation/park
abstract:内核同步原语是任何操作系统设计的骨干。例如，内核锁对于应用程序的性能和正确性都至关重要。然而，与应用程序锁不同，内核锁远离应用开发者的触手可及，他们对内核行为的理解非常有限，无法控制或影响管理内核同步行为的策略。内核与应用程序之间的这种脱节可能导致病态场景，其中在一个高竞争上下文中优化内核同步原语会在无锁竞争的上下文下产生对立的效果。此外，快速演变的异构硬件使得内核锁的开发对于有严格性能要求和频繁部署时间线的现代应用程序来说太慢了。

本文通过应用程序通知的内核同步原语来解决上述问题。我们允许应用开发者部署针对工作负载特定和硬件感知的内核锁策略，以提升应用程序性能，解决内核锁的病态使用，甚至启用对感兴趣的锁进行动态分析。为了展示这个想法，我们设计了SynCord，一个在不重新编译或重启内核的情况下修改内核锁的框架。SynCord抽象了内核锁的关键行为，并将其作为API暴露出来，用于设计用户定义的内核锁。SynCord提供了从用户空间安全、正确地自定义内核锁的机制。我们设计了五种针对新的异构硬件和特定软件要求的锁策略。我们的评估显示，SynCord带来的运行时开销最小，并生成了与最先进的锁性能相当的内核锁。
#### Userspace Bypass: Accelerating Syscall-intensive Applications
link:https://www.usenix.org/conference/osdi23/presentation/zhou-zhe
abstract:在内核模式和用户模式之间进行上下文切换经常会导致显著的开销，这降低了频繁进行系统调用（或称为syscalls）的应用程序的速度，例如那些具有高I/O需求的应用程序。安全机制如Linux内核的页表隔离（KPTI）进一步放大了这种开销。为了加速这类应用程序，许多努力已经被投入到从I/O路径中移除系统调用，主要通过将驱动程序和应用程序合并到同一空间或批处理系统调用。然而，这些解决方案要求开发者重构他们的应用程序甚至更新硬件，这阻碍了它们的广泛采用。

在本文中，我们提出了另一种方法，用户空间绕过（UB），通过将用户空间指令透明地移动到内核中来加速系统调用密集型应用程序。用户空间绕过不需要修改用户空间的二进制文件或代码，并实现了完全的二进制兼容性。具体来说，为了避免频繁系统调用造成的开销，内核识别连续系统调用之间短暂的用户空间执行路径，并将路径中的指令转换为带有基于软件的故障隔离（SFI）保证的代码块。根据我们的评估，当应用程序在开启KPTI的虚拟化环境中执行时，I/O微基准可以加速30.3 – 88.3%，Redis GET请求每秒（RPS）可以对于1B – 4KiB数据大小提高4.4 – 10.8%。当关闭KPTI时，性能提升将会减少。
#### Towards a Machine Learning-Assisted Kernel with LAKE
link:https://dl.acm.org/doi/10.1145/3575693.3575697
abstract:现代操作系统（OS）的复杂性、硬件的快速多样化以及机器学习（ML）的稳步演进促使我们探索利用ML改进OS内核决策制定的潜力。我们推测，ML可以更好地管理那些目前依赖手工调整启发式算法以提供合理平均情况性能的子系统（如内存管理、进程和I/O调度）的权衡空间。我们探索在五个内核子系统中用ML驱动的决策制定来替换启发式算法，考虑对内核设计、共享的OS级组件和硬件加速访问的含义。我们识别障碍，解决挑战，并为ML在内核空间能提供的好处所带来的权衡进行特征化。我们发现，使用如GPU这样的专用硬件对于吸收ML决策所需的额外计算负载至关重要，但在内核空间中加速器的可访问性差是采用的一个障碍。我们还发现，对操作系统的ML和加速的好处依赖于子系统、工作负载和硬件，这表明在内核中使用ML将需要框架来帮助内核开发者导航新的权衡空间。我们通过构建一个名为LAKE的系统来解决这些挑战，以支持ML并在内核空间中暴露加速器。LAKE包括用于跨抽象层和模块边界收集和管理特征的API。LAKE为管理加速的可变利益提供机制，并为缓解用户空间与内核空间之间资源竞争提供接口。我们展示了一个ML支持的I/O延迟预测器可以通过加速将其推理时间减少高达96%。